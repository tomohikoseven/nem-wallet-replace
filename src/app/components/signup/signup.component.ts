import { Component, OnInit, Inject, HostListener, Renderer2 } from '@angular/core';
import { DOCUMENT } from '@angular/common';

// Service
import { LocalStorageService } from '../../providers/local-storage.service';
import { AlertService } from '../../providers/alert.service';
import { WalletBuilderService } from '../../providers/wallet-builder.service';
import { WalletService } from '../../providers/wallet.service';
//import { AddressBookService, Wallet } from '../../providers/address-book.service';
import { AddressBookService } from '../../providers/address-book.service';

// Pipe
import { ToNetworkNamePipe } from '../../pipes/to-network-name.pipe';
import { FmtAddressPipe } from '../../pipes/fmt-address.pipe';

// config
import { AppConstants } from '../../config/app.constants';

// utils
import { Helpers } from '../../utils/helpers';

// class
import { Wallet } from '../../class';

import  nem  from 'nem-sdk';
import zxcvbn from 'zxcvbn';

class WalletType {
  type:number = undefined;
}

class SelectedType {
  type: number = undefined;
}

class FormData {
  password: string;
  confirmPassword: string;
  walletName: string;
  privateKey: string;
  entropy: string;
}

interface Work {
  id: number;
  prefix: string;
  char: string;
}

@Component({
  selector: 'signup',
  templateUrl: './signup.component.html',
  styleUrls: ['./signup.component.scss']
})
export class SignupComponent implements OnInit {
  network: number;
  _selectedType: SelectedType;
  passwordStrengthInfo: {};
  walletTypes : Array<WalletType>;
  generatedAddress: string;
  formData: FormData;
  networks: any; //Networks;
  okPressed: boolean;
  rawWallet: string;
  walletPrivateKey: string;
  tempWallet: Wallet;
  width:number;
  entropy: string;

  start: boolean;
  step1: boolean;
  step2: boolean;
  step3: boolean;
  step4: boolean;
  step5: boolean;
  step6: boolean;
  step7: boolean;
  step8: boolean;
  step9: boolean;
  progressBar: boolean;
  entropyDone: boolean;

  showInfo: number;
  showPassword: boolean;

  getEntropyFunc: Function;

  constructor(
    private _storage: LocalStorageService,
    private _Alert: AlertService,
    private _WalletBuilder: WalletBuilderService,
    private _Wallet: WalletService,
    private _AddressBook: AddressBookService,
    private renderer: Renderer2,
    @Inject(DOCUMENT) document
  ) { 
    this.network = AppConstants.defaultNetwork;

    // Available networks
    this.networks = nem.model.network.data;
    //console.log(this.networks);

    // Get wallets from local storage or set an empty array
    this._storage.wallets = this._storage.wallets || [new Wallet()];

    // Lock to prevent user to click twice on button when already processing
    this.okPressed = false;

    // Raw wallet data to show in view
    this.rawWallet = "";

    // Wallet private key to show in view
    this.walletPrivateKey = "";

    // Store created wallet temporarily
    this.tempWallet = undefined;

    // Form data object
    this.formData = new FormData();
    this.formData.password = "";
    this.formData.confirmPassword = "";
    this.formData.walletName = "";
    this.formData.privateKey = "";
    this.formData.entropy = "";

    // Address generated by provided private key (private key wallet)
    this.generatedAddress = "";

    // Wallet types
    this.walletTypes = [{
        "type": 1 // Simple
    }, {
        "type": 2 // Brain
    }, {
        "type": 3 // Private key
    }];

    // Selected wallet type
    this._selectedType = undefined;

    // Password strength info given by zxcvbn
    this.passwordStrengthInfo = {};
  }

  ngOnInit() {
  }

  //// Module methods region ////

  /**
   * Change the selected wallet type
   *
   * @param {number} type - Type number
   */
  changeWalletType(type: number) {
      this._selectedType = this.walletTypes[type - 1];
  }

  /**
   * Change wallet network
   *
   * @param {number} id - The network id to use at wallet creation
   */
  changeNetwork() {
      if (this.network == nem.model.network.data.mijin.id && AppConstants.mijinDisabled) {
          this._Alert.mijinDisabled();
          // Reset network to default
          this.network = AppConstants.defaultNetwork;
          return;
      } else if (this.network == nem.model.network.data.mainnet.id && AppConstants.mainnetDisabled) {
          this._Alert.mainnetDisabled();
          // Reset network to default
          this.network = AppConstants.defaultNetwork;
          return;
      }
  }

  /**
   * Arrange wallet data to show in safety protocol
   *
   * @param {object} wallet - A wallet object
   */
  arrangeSafetyProtocol(wallet:Wallet) {
      // Store wallet temporarily until safety protocol done
      this.tempWallet = wallet;
      // Prepare download
      this._Wallet.prepareDownload(wallet);
      // Store base64 format for safety protocol
      this.rawWallet = this._Wallet.base64Encode(wallet);
      // Unlock button
      this.okPressed = false;
      return;
  }

  /**
   * Create a new PRNG wallet
   */
  createWallet() {
      // Check if passwords match
      if (!this.checkPasswordsMatch()) return;

      // Lock button
      this.okPressed = true;

      // Create the wallet from form data
      return this._WalletBuilder.createWallet(this.formData.walletName, this.formData.password, this.formData.entropy, this.network).then((wallet:Wallet) => {
          setTimeout(() => {
              if (wallet && typeof wallet === 'object') {
                  //
                  this.arrangeSafetyProtocol(wallet);
                  // We need private key for view so we create a common object with the wallet password
                  let common = nem.model.objects.create("common")(this.formData.password, "");
                  // Decrypt / generate and check primary
                  if (!this._Wallet.decrypt(common, wallet.accounts[0], wallet.accounts[0].algo, wallet.accounts[0].network)) {
                      // Enable send button
                      this.okPressed = false;
                      return;
                  } else {
                      // Set the decrypted private key for view
                      this.walletPrivateKey = common.privateKey;
                  }
                  // Hide step
                  this.step4 = false;
                  // Show next step
                  this.step5 = true;
                  return;
              }
          }, 10);
      },
      (err) => {
          // Unlock button
          this.okPressed = false;
          return;
      });
  }

  /**
   * Create a new brain wallet
   */
  /*createBrainWallet() {
      // Check if passwords match
      if (!this.checkPasswordsMatch()) return;

      // Mainnet passphrase must be at least 40 characters long
      if (this.network === nem.model.network.data.mainnet.id && this.formData.password.length < 40) {
          this._Alert.brainPasswordTooShort();
          return;
      }

      // Mainnet passphrase must have a score of at least 3/4
      if (this.network === nem.model.network.data.mainnet.id && zxcvbn(this.formData.password).score < 3) {
          this._Alert.passphraseIsWeak();
          return;
      }

      // Lock button
      this.okPressed = true;

      // Create the wallet from form data
      return this._WalletBuilder.createBrainWallet(this.formData.walletName, this.formData.password, this.network).then((wallet) => {
          this._$timeout(() => {
              if (wallet && typeof wallet === 'object') {
                  //
                  this.arrangeSafetyProtocol(wallet);
                  // Store private key for account safety protocol
                  this.walletPrivateKey = nem.crypto.helpers.derivePassSha(this.formData.password, 6000).priv;
                  // Hide step
                  this.step3 = false;
                  // Show next step
                  this.step5 = true;
                  return;
              }
          }, 10);
      },
      (err) => {
          // Unlock button
          this.okPressed = false;
          return;
      });
  }*/

  /**
   * Create a new private key wallet
   */
  createPrivateKeyWallet() {
      // Check if passwords match
      if (!this.checkPasswordsMatch()) return;

      // Lock button
      this.okPressed = true;

      // Create the wallet from form data
      return this._WalletBuilder.createPrivateKeyWallet(this.formData.walletName, this.formData.password, this.formData.privateKey, this.network).then((wallet:Wallet) => {
          setTimeout(() => {
              if (wallet && typeof wallet === 'object') {
                  //
                  this.arrangeSafetyProtocol(wallet);
                  this.walletPrivateKey = this.formData.privateKey;
                  // Hide step
                  this.step4 = false;
                  // Show next step
                  this.step5 = true;
                  return;
              }
          }, 10);
      },
      (err) => {
          // Unlock button
          this.okPressed = false;
          return;
      });
  }

  /**
   * Generate the address from private key to import
   */
  generateAddress():void {
      if(undefined !== this.formData.privateKey && this.formData.privateKey.length) {
          // Check private key
          if (nem.utils.helpers.isPrivateKeyValid(this.formData.privateKey)) {
              // Create key pair
              let kp = nem.crypto.keyPair.create(this.formData.privateKey);
              // Create address to show
              this.generatedAddress = nem.model.address.toAddress(kp.publicKey.toString(), this.network);
          } else {
              // Reset address
              this.generatedAddress = "";
              // Show error alert
              this._Alert.invalidPrivateKey();
          }
      }
  }

  /**
   * Check if a wallet name is already present in local storage
   */
  checkWalletNamePresence():boolean {
      if (Helpers.haveWallet(this.formData.walletName, this._storage.wallets)) return true;
      return false;
  }

  /**
   * Check if password and confirmation are the same
   */
  checkPasswordsMatch():boolean {
      if (this.formData.password !== this.formData.confirmPassword) {
          this._Alert.passwordsNotMatching();
          return false;
      }
      return true;
  }

  /**
   * Hide signup steps / reset to wallet type selection
   */
  hideAllSteps():void {
      this.start = false;
      this.step1 = false;
      this.step2 = false;
      this.step3 = false;
      this.step4 = false;
      this.progressBar = false;
      this.entropyDone = false;
      let pbar = document.getElementById("pBar");
      if(!pbar){
        document.getElementById("pBar").style.width = '0%';
        //console.log('yes. pbar!');
      }
      this.formData.entropy = "";
  }

  /**
   * Watch cursor movements to add more entropy to key generation (simple wallet)
   */
  @HostListener('click', ['$event'])  // TODO:このクリックリスナーを外したい。外すと、メソッド内のmousemoveのリスナーが登録できない。
  getEntropy() {
      // Prepare
      let elem = document.getElementById("pBar");
      //console.log(elem);
      if( elem == null ){
        return;
      }
      this.width = 0;
      this.entropy = "";
      // Watch for cursor movements
      let getEntropyFunc =  this.renderer.listen('document', 'mousemove', e => {
        //console.log("pos x: " + e.pageX);
        //console.log("pos y: " + e.pageY);
        //console.log("this.width:" + this.width);
        if (this.width >= 100) {
            setTimeout(() => {
                document.removeEventListener('click', this.getEntropy); // remove handler
                // TODO:リスナーの削除方法がこれ以外にあるのか
                this.renderer.listen('document', 'mousemove', e => { });
                elem.innerHTML = '<span class="fa fa-check-circle" aria-hidden="true"></span> Done!';
                this.entropyDone = true;
                console.log('1 this.formData.entropy');
                console.log('2 this.entropy');
                this.formData.entropy = this.entropy;
            });
        } else {
            this.entropy += e.pageX + "" + e.pageY;
            this.width += 0.15; 
            elem.style.width = this.width + '%'; 
            elem.innerHTML = Math.round(this.width * 1)  + '%';
        }
      });
  }

  /**
   * Finalize signup process
   */
  endSignup() {
      // Store wallet temporarily until safety protocol done
      let wallet = this.tempWallet;
      // Add the account into address book
      this._AddressBook.addAccount(wallet.accounts[0].address);
      // Set wallet in local storage
      this._storage.wallets = this._storage.wallets.concat(wallet);
      // Show success alert
      this._Alert.createWalletSuccess();
      // Reset form data
      this.formData = undefined;
      this.step8 = false;
      this.step9 = true;
  }

  /**
   * Update the passphrase strength information
   */
  updatePasswordStrengthInfo():void {
      this.passwordStrengthInfo = zxcvbn(this.formData.password);
  }

}
